---
import PublicLayout from '../../layouts/PublicLayout.astro';
import Button from '../../components/ui/Button.astro';
import Stripe from 'stripe';
import { createServerClient } from '../../lib/supabase';

export const prerender = false;

const sessionId = Astro.url.searchParams.get('session_id');

if (!sessionId) {
  return Astro.redirect('/');
}

// Order processing logic
let orderCreated = false;
let orderError = null;
let orderDetails = null;

try {
  const stripe = new Stripe(import.meta.env.STRIPE_SECRET_KEY || '', {
    apiVersion: '2023-10-16' as any,
  });

  const session = await stripe.checkout.sessions.retrieve(sessionId);

  if (session.payment_status === 'paid') {
    const supabaseAdmin = createServerClient(import.meta.env.SUPABASE_SERVICE_ROLE_KEY);
    
    // 1. Check if order already exists
    const { data: existingOrder } = await supabaseAdmin
      .from('orders')
      .select('id, order_number')
      .eq('payment_intent_id', session.payment_intent)
      .single();

    if (existingOrder) {
      orderCreated = true;
      orderDetails = existingOrder;
    } else {
      // 2. Create order if it doesn't exist (Fallback for Webhook)
      const metadata = session.metadata;
      
      if (metadata && metadata.items) {
        const items = JSON.parse(metadata.items);
        const customerEmail = session.customer_details?.email || '';
        const customerName = metadata.customerName || session.customer_details?.name || 'Cliente';
        const customerPhone = session.customer_details?.phone || '';
        const discountCode = metadata.discountCode || null;
        
        // Calculate discount amount if needed (simplified)
        // In a real scenario, this should come from session.total_details.amount_discount
        const discountAmount = session.total_details?.amount_discount || 0;

        const shipping = session.shipping_details?.address;
        const shippingAddress = {
            line1: shipping?.line1,
            line2: shipping?.line2,
            city: shipping?.city,
            state: shipping?.state,
            postal_code: shipping?.postal_code,
            country: shipping?.country,
        };

        let insertedOrderId = null;

        try {
            // First attempt: Try using the RPC function
            const { data: rpcData, error: rpcError } = await supabaseAdmin.rpc('process_order', {
                p_customer_email: customerEmail,
                p_customer_name: customerName,
                p_customer_phone: customerPhone,
                p_shipping_address: shippingAddress,
                p_items: items.map((i: any) => ({
                    product_id: i.id,
                    quantity: i.quantity,
                    size: i.size,
                    color: i.color || null
                })),
                p_shipping_cost: session.total_details?.amount_shipping || 0,
                p_tax: session.total_details?.amount_tax || 0,
                p_discount_amount: discountAmount,
                p_discount_code: discountCode,
                p_payment_intent_id: session.payment_intent as string,
                p_total: session.amount_total || 0
            });

            if (rpcError) throw rpcError;
            insertedOrderId = rpcData;

        } catch (processError: any) {
            console.error('RPC failed, attempting direct insert:', processError);
            
            // Fallback: Direct insertion using Service Role (Admin)
            // This bypasses potential RPC issues
            
            // 1. Fetch real prices from DB to ensure valid subtotal and unit_price
            // Metadata does not contain prices for security
            const productIds = items.map((i: any) => i.id);
            const { data: dbProducts } = await supabaseAdmin
                .from('products')
                .select('id, price, name')
                .in('id', productIds);
            
            const productsMap = new Map(dbProducts?.map(p => [p.id, p]) || []);

            const itemsWithPrices = items.map((item: any) => {
                const dbProduct = productsMap.get(item.id);
                const price = dbProduct?.price || 0;
                return {
                    ...item,
                    price: price,
                    name: dbProduct?.name || item.name || 'Producto'
                };
            });

            // Calculate totals using real prices
            const subtotal = itemsWithPrices.reduce((sum: number, item: any) => sum + (item.price * item.quantity), 0);
            
            // Generate a random order number
            const randomSuffix = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
            const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const orderNumber = `FS-${dateStr}-${randomSuffix}`;
            
            // 2. Insert Order
            const { data: orderData, error: orderInsertError } = await supabaseAdmin
                .from('orders')
                .insert({
                    order_number: orderNumber,
                    customer_email: customerEmail,
                    customer_name: customerName,
                    customer_phone: customerPhone,
                    shipping_address: shippingAddress,
                    subtotal: subtotal,
                    shipping_cost: session.total_details?.amount_shipping || 0,
                    tax: session.total_details?.amount_tax || 0,
                    total: session.amount_total ?? (subtotal - discountAmount),
                    status: 'paid', // Direct to paid
                    payment_status: 'paid',
                    payment_intent_id: session.payment_intent as string,
                    discount_amount: discountAmount,
                    discount_code: discountCode
                })
                .select('id')
                .single();

            if (orderInsertError) throw new Error(`Direct insert failed: ${orderInsertError.message}`);
            
            insertedOrderId = orderData.id;

            // 3. Insert Items
            const orderItemsData = itemsWithPrices.map((item: any) => ({
                order_id: insertedOrderId,
                product_id: item.id,
                product_name: item.name, 
                quantity: item.quantity,
                size: item.size,
                color: item.color,
                unit_price: item.price,
                total_price: item.price * item.quantity
            }));
            
            const { error: itemsError } = await supabaseAdmin.from('order_items').insert(orderItemsData);
            if (itemsError) console.error('Error inserting items:', itemsError);
            
            // 4. Update Stock (Best effort)
            // 4. Update Stock (Best effort)
            for (const item of items) {
                let stockUpdated = false;
                
                // Try RPC first
                try {
                    const { data: success, error: stockError } = await supabaseAdmin.rpc('decrement_stock', {
                        p_product_id: item.id,
                        p_quantity: item.quantity
                    });
                    
                    if (!stockError && success === true) {
                        stockUpdated = true;
                        console.log(`Stock decremented via RPC for ${item.id}`);
                    } else {
                        console.warn(`RPC decrement_stock failed for ${item.id}:`, stockError?.message || 'Returned false');
                    }
                } catch (rpcErr) {
                    console.error('RPC call exception:', rpcErr);
                }

                // Manual fallback if RPC failed
                if (!stockUpdated) {
                     console.log(`Attempting manual stock update for ${item.id}`);
                     const { data: product } = await supabaseAdmin.from('products').select('stock').eq('id', item.id).single();
                     
                     if (product) {
                         const newStock = Math.max(0, product.stock - item.quantity);
                         // Force update even if RLS tries to block it (we are admin)
                         const { error: updateError } = await supabaseAdmin
                            .from('products')
                            .update({ stock: newStock })
                            .eq('id', item.id);
                            
                         if (updateError) {
                             console.error('Manual stock update failed:', updateError.message);
                         } else {
                             console.log(`Manual stock update success for ${item.id}. New stock: ${newStock}`);
                         }
                     }
                }
            }
        }
        
        const orderId = insertedOrderId;
        
        // Update user_id if logged in and link the order
        const updateFields: any = {};
        
        const accessToken = Astro.cookies.get('sb-access-token')?.value;
        if (accessToken) {
            const { data: { user } } = await supabaseAdmin.auth.getUser(accessToken);
            if (user && user.email === customerEmail) {
                updateFields.user_id = user.id;
            }
        }

        // If RPC was successful (not fallback), we might need to update discount info too if process_order didn't handle it
        // But since fallback handles it, we only update if fields are missing.
        // For simplicity, we ensure user_id is linked.
        
        if (Object.keys(updateFields).length > 0) {
            const { error: updateError } = await supabaseAdmin
                .from('orders')
                .update(updateFields)
                .eq('id', orderId);

             if (updateError) console.error('Error updating order on success page:', updateError);
        }

        orderCreated = true;
        
        // Fetch full order to be sure we have everything for the email/display
        const { data: finalOrder } = await supabaseAdmin.from('orders').select('*').eq('id', orderId).single();
        if (finalOrder) {
             orderDetails = finalOrder;
             
             // Send email explicitly since we are creating the order here (fallback flow)
             try {
                const { sendOrderConfirmationEmail } = await import('../../lib/email');
                const { data: finalItems } = await supabaseAdmin.from('order_items').select('*').eq('order_id', orderId);
                
                if (finalItems) {
                    await sendOrderConfirmationEmail({
                        orderNumber: finalOrder.order_number,
                        customerName: finalOrder.customer_name,
                        customerEmail: finalOrder.customer_email,
                        items: finalItems.map((item: any) => ({
                            name: finalOrder.product_name || item.product_name || 'Producto',
                            quantity: item.quantity,
                            price: item.unit_price,
                            total: item.total_price,
                            image: item.product_image
                        })),
                        subtotal: finalOrder.subtotal,
                        shipping: finalOrder.shipping_cost,
                        tax: finalOrder.tax,
                        total: finalOrder.total,
                        shippingAddress: finalOrder.shipping_address,
                        date: finalOrder.created_at
                    });
                }
             } catch (emailErr) {
                 console.error('Error sending email on success page:', emailErr);
             }
        } else {
             orderDetails = { id: orderId };
        }

      }
    }
  }
} catch (err: any) {
  console.error('Error processing order on success page:', err);
  orderError = `Error procesando el pedido: ${err.message || 'Error desconocido'}`;
}

---

<PublicLayout title="¡Pedido Confirmado! | FashionStore">
  <div class="min-h-[60vh] flex items-center justify-center px-4 py-16 bg-cream-50">
    <div class="max-w-lg w-full text-center bg-white p-8 rounded-2xl shadow-xl border border-primary-100 animate-slide-up">
      <div class="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
        <svg class="w-10 h-10 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
        </svg>
      </div>
      
      <h1 class="text-3xl font-serif font-bold text-primary-950 mb-4">
        ¡Gracias por tu compra!
      </h1>
      
      <p class="text-primary-700 mb-8 leading-relaxed text-lg">
        Tu pedido ha sido procesado correctamente. Hemos enviado un correo de confirmación con los detalles.
      </p>

      {orderDetails && (
         <div class="bg-primary-50 border border-primary-200 rounded-xl p-4 mb-8">
            <p class="text-primary-800 font-medium">Numero de orden</p>
            <p class="text-2xl font-mono font-bold text-primary-600 tracking-wider">
              {orderDetails.order_number || orderDetails.id.slice(0, 8).toUpperCase()}
            </p>
         </div>
      )}
      
      {orderError && (
        <div class="bg-red-50 border border-red-200 rounded-xl p-4 mb-8 text-left">
          <p class="text-red-800 font-bold flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            Hubo un problema registrando tu pedido
          </p>
          <p class="text-red-600 text-sm mt-1">
            {orderError}
          </p>
          <p class="text-red-500 text-xs mt-2">
            Por favor, contacta con soporte con tu ID de sesión.
          </p>
        </div>
      )}
      
      <div class="space-y-4">
        <Button href="/productos" variant="primary" fullWidth class="shadow-lg hover:shadow-xl transition-all">
          Seguir comprando
        </Button>
        <Button href="/cuenta/pedidos" variant="outline" fullWidth>
          Ver mis pedidos
        </Button>
      </div>
      
      <div class="mt-8 pt-6 border-t border-primary-100">
        <p class="text-xs text-primary-400 font-mono">
          ID de Sesión: {sessionId.slice(0, 10)}...
        </p>
      </div>
    </div>
  </div>
</PublicLayout>

<script>
  // Clear cart on success
  import { clearCart } from '../../stores/cart';
  clearCart();
</script>
